<html>
    <head>
        <style>
            body {
                margin: 0;
            }
            canvas {
                background: lightgrey;
            }
        </style>
    </head>
    <body>
        <script src="ffl_wasm.js"></script>
        <canvas id="canvas" width="512" height="512"></canvas>
        <canvas id="canvas2" width="256" height="512"></canvas>

        <script type="module">
            import * as THREE from 'three';

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

            const renderer = new THREE.WebGLRenderer();
            renderer.setClearColor( 0xafafaf, 1 );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            camera.position.z = 2;

            const canvas = document.querySelector("#canvas");

            const canvas2 = document.querySelector("#canvas2")
            const ctx2d = canvas2.getContext("2d");

            /*
            struct MeshData {
                uint32_t vertexCount;
                uint32_t indexCount;

                void* indexData;

                void* positionData;
                void* uvData;
                void* normalData;
                void* tangentData;
                void* colorData;
            };
             */
            function getOffsetData(stride, count, data) {
                let length = stride * count * 4;
                data.offset += length;
                return length;
            }
            function copyMeshData(pointer) {
                let vertexCount = Module.HEAPU32[pointer / 4];
                let indexCount = Module.HEAPU32[(pointer / 4) + 1];

                console.log(pointer)
                let data = {
                    color: {
                        r: Module.HEAPF32[(pointer / 4) + 2],
                        g: Module.HEAPF32[(pointer / 4) + 3],
                        b: Module.HEAPF32[(pointer / 4) + 4]
                    },
                    offset: pointer + (4 * 4),
                    vertexCount, indexCount
                }
                // TODO: figure out how the fuck we're going to read this
                data.indexData = Module.HEAPU32.slice(Module.HEAPU32[data.offset], Module.HEAPU32[data.offset] + getOffsetData(4, data.indexCount, data));

                return data;
            }

            fetch("AFLResHigh_2_3.dat")
                .then(_ => _.arrayBuffer())
                .then(async data => {
                    // expose to context for debugging purpose (this is disgusting)
                    let context = Module.GL.registerContext(renderer.getContext(), {
                        majorVersion: 1
                    });
                    Module.GL.makeContextCurrent(context);

                    // Start up FFL (store miiAddress)
                    let address = Module.ccall("init", ["number"], ["number"], [data.byteLength]);
                    Module.HEAPU8.set(new Uint8Array(data), address);
                    let miiAddress = Module.ccall("init", ["number"], null);
                    console.log(!miiAddress ? "Failed to start" : "FFL good")

                    // Set Mii
                    let miiData = [0x03, 0x00, 0x00, 0x40, 0xA0, 0x41, 0x38, 0xC4, 0xA0, 0x84, 0x00, 0x00, 0xDB, 0xB8, 0x87, 0x31, 0xBE, 0x60, 0x2B, 0x2A, 0x2A, 0x42, 0x00, 0x00, 0x59, 0x2D, 0x4A, 0x00, 0x61, 0x00, 0x73, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x37, 0x12, 0x10, 0x7B, 0x01, 0x21, 0x6E, 0x43, 0x1C, 0x0D, 0x64, 0xC7, 0x18, 0x00, 0x08, 0x1E, 0x82, 0x0D, 0x00, 0x30, 0x41, 0xB3, 0x5B, 0x82, 0x6D, 0x00, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x69, 0x00, 0x67, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x3A];
                    Module.HEAPU8.set(new Uint8Array(miiData), miiAddress);
                    Module.ccall("mii", "boolean");

                    // Drawing textures (call each of these)
                    Module.ccall("drawFaceTexture", null, ["number"], [0]);
                    Module.ccall("drawFaceline");
                    Module.ccall("drawXlu");

                    // Exporting texture data to RGBA (I will abstract this sooner or later)
                    // NOTE: There is NO validation for textures like this. Typically it'll say something like "ran out of memory". This means your texture name is invalid.
                    let exportData = Module.ccall("exportTexture", ["number"], ["string"], ["FACELINE"]);
                    let width = Module.HEAPU32[exportData / 4]; // offset 0
                    let height = Module.HEAPU32[(exportData + 4) / 4]; // offset 4 (1 32-bit unsigned integer)
                    let pixelData = Module.HEAPU8.slice(Module.HEAPU32[(exportData + 8) / 4], Module.HEAPU32[(exportData + 8) / 4] + (width * height * 4));  // offset 8 (2 32-bit unsigned integer)

                    // Setting the pixel data on the canvas
                    let canvasPixelData = ctx2d.getImageData(0, 0, width, height);
                    canvasPixelData.data.set(pixelData, 0);
                    ctx2d.putImageData(canvasPixelData, 0, 0);

                    // Mesh data

                    let hairMesh = copyMeshData(Module.ccall("getMesh", "number", ["string"], ["HAIR"]));
                    console.log(hairMesh);
                })
        </script>
    </body>
</html>